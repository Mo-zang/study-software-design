### 데이터 저장소를 위한 버전 관리

#### 프로토콜 버퍼에 대한 간략한 소개
* 프로토콜 버퍼 : 구글 내부에서 고안되어 광범위하게 사용되는 직렬화 형식이며, gRPC, RPC 프레임워크와 함께 더 광범위한 생태계에서 많이 사용되고 있음.
  * 효율적인 바이너리 저장소를 위해 설계되었지만, JSON 표현법도 지원한다.
* Protobuf 스키마 파일의 구성요소
  * 메시지 (message) : 대다수 proto 파일의 주요 부분이며, 대다수 프로그래밍 언어 내에서 타입을 정의하는 방식과 거의 유사함.
    * 필드를 포함하며, 중첩된 메시지와 열거형도 포함할 수 있음.
  * 열거형 (enum) : 명명된 정수 매핑을 정의함.
  * 서비스 (service) : RPC를 정의하기 위해 사용됨. gRPC와 프로토콜 버퍼는 상당히 자주 함께 사용되지만, gRPC없이 프로토콜 버퍼를 사용하는 RPC 프레임워크를 설계하거나 protobuf 형식이 아닌 데이터와 함께 gRPC를 사용하는것도 전적으로 가능하다.
* 메시지 내에서 각 필드의 세가지 주요측면
  * 타입 : 기본 타입 (정수, 부동소수점 수, 바이트 문자열, 텍스트 문자열)이나 열거형이나 메시지 중 하나가 될 수 있음.
    * 타입은 사실상 리스트인 **반복되는** 필드를 지시할 수도 있음.
  * 이름 : 생성된 코드나 JSON으로 메시지를 인코딩할 때 사용된다.
  * 숫자 : 바이너리 직렬화 형식에서 사용된다.

* 프로토 스키마 예제 (롤플레잉 게임 캐릭터를 위한 예제)
  ```protobuf
  syntax = "proto3";
  message Character {
    string name = 1;
    bytes icon_png = 2;
    Profession profession = 3;
    repeated Item inventory = 4;
    // 가용 슬롯의 최대 수
    int32 inventory_slots = 5;
    int32 health = 5;
    int32 max_health = 6;
  }

  meassage Item {
    string name = 1;
    // 물품 목록에서 차지하는 슬롯 수
    int32 slots = 2;
  }

  enum Profession {
    PROFESSION_UNKNOWN = 0;
    MAGE = 1;
    THIEF = 2;
    WARRIOR = 3;
  }
  ```

#### 호환성이 손상되는 변경 사항은 무엇일까?
* 하이럼의 법칙
  * 어떤 코드 변경도 누군가에게는 호환성에 손상을 입힐 수 있다고 제안하는 법칙
    * 온라인에 공개되어있는 API는 누군가 쓰고 있다고 생각해야한다.
* 저장소 형식에 호환성이 손상되는 변경을 가하는 작업은 코드보다 훨씬 더 어렵기에 가볍게 여겨서는 안된다.

#### 예상치 못한 상황을 예상하기

##### 열거형 값 추가하기
* 필드 추가는 기존 로직을 간섭하지 않을 수 있지만 열거형은 추론하기가 약간 더 까다롭다.
* 열거형은 코드를 생성할 시점에서 모든 알려진 값을 의미한다.
* MIME 타입이나 ISO-3166 국가 코드와 같이 업계 표준이 존재한다면, 해당 문자열 값을 열거형 대신 사용하는게 좋다.


#### API와 저장소 표현 분리하기

##### 네트워크 API 스키마와 저장소 스키마를 분리해서 유지하자
* API 스키마를 분리하는 작업의 유형
  * 저장소 스키마를 API 스키마로 어떻게 변환할지
  * 두 스키마 사이에서 데이터를 어떻게 변환할지

##### 수동 변환
* 저장소 스키마를 네트워크 API 스키마로 변환하는 가장 단순한 방법
  * 복사 + 붙여넣기 -> 편집
    * 패키지 이름이나 네임스페이스를 잠재적으로 변경하는것 외에는 큰 변경사항이 없음.
    * 실행시간에 데이터를 변환하는 작업은 오류가 많을 수 있음.
      * 통합 테스트에서 대부분 다 잡아내야 바람직함.
    * 장점
      * 원본 스키마 변경을 넘어 연쇄적으로 바꿔나가는 동안 사고의 규율을 유지할 수 있다면 결국 문제나 기회를 발견하게 될 수 있음.

##### 자동 변환
* 공개된 도구를 사용하거나 직접 제작하여 사용하는 방법
  * 직접 제작한다면 유지보수에 어려움이 생길 수 있으나, 유연성이 높아짐
* 변환을 위해 리플렉션 API 사용시 벤치마크 잘 해두면 좋다.

#### 저장소 형식 평가하기
* 저장소가 심지어 스키마 없는 방식을 지원하더라도 어떤 형태로든 스키마를 지원하는가?
* 저자소가 스키마 진화를 위해 바로 사용 가능한 형태의 지원을 제공하는가?
* 예를 들어, 아파치 아브로는 처음부터 이를 염두에 두고 설계되었으며, 이를 강제하기 위한 호환성 규칙과 도구를 제공한다.
* 클라이언트가 사용하는 스키마에 존재하지 않았던 필드나 열거형 값과 같이 예상치 못한 값을 저장소는 어떻게 처리 하는가?
* 스키마 변경을 빌드 과정에 어떻게 포함시키는가? 가상의 데이터 이주를 위한 일련의 단계를 작성하는 등 몇 가지 계획 연습을 직접 해보는 편이 도움될 수 있다.
* 생성된 코드를 사용할 계획이라면 내부 코드 버전 전략에 영향을 미치는가? 저장소의 호환성이 손상되지는 않지만, 기존 코드의 호환성이 손상되는 스키마 변경에 대한 정책은 무엇인가?
* 저장소와 API 표현 양쪽에 동일 형식을 사용하고 싶은가? 그렇다면 다음 몇 가지 질문을 스스로에게 해보자
  * 스키마 변환을 위한 도구가 있거나 아니면 최소한 도구를 작성하게 지원하는가?
  * 서로 다른 스키마 사이에서 데이터 변환을 위한 도구나 지원이 존재하는가?
  * 계획된 API 버전 전략에 어떻게 맞아떨어지는가?
