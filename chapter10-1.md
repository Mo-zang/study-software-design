## 분산 시스템에서의 일관성과 원자성
* 시스템에서 일관성 있는 View는 중요하다.
* 
### 최소한 한 번 이상 데이터 소스 전송

#### 노드 하나짜리 서비스 사이의 트래픽
* 노드 하나에 배포되어 있는 서비스에서 메일 서비스 호출을 수행할 필요가 있다고 가정
  * 메일 서비스는 요청을 받을 때 이메일을 최종 사용자에게 전송.
    * 해당 경우 서비스를 분산된 환경에서 운영하는것.
* 모든 네트워크 요청은 실패할 수 있다고 가정해야함.
  * 네트워크 실패시 애플리케이션은 호출 수행결과를 예측할 수 없음.
    * 일관성을 유지하지 못하는경우 발생.

#### 애플리케이션 호출 재시도하기
* 애플리케이션이 성공적인 응답을 받지 못할 때 해법으로 호출을 재시도 할 수 있음.
  * 네트워크 문제인 경우 재시도가 성공할 확률이 높다.
  * 재시도를 2번 이상 해야하는 경우 문제가 발생함.
    * 1번째 시도가 실패 -> 2번째 시도도 실패하고 다시 재시도 하는경우
      * 이메일이 세 번까지 전송될 가능성이 있음. (직전에 보낸 이메일이 전송 전 실패인지 전송 후 실패인지 모르기 때문)
      * 해당 경우가 만약 결제와 관련되어 있다면 크리티컬한 문제가 생김. -> 결제가 이미 완료되었음에도 중복으로 결제를 요청하는 경우

#### 데이터 생성과 멱등성
* 시스템의 멱등성 특성
  * **서비스에 연산이나 요청을 여러 번 수행해도 결과가 처음 한 번 했을 때와 같은경우**
  * Ex : 특정 값(PK)과 일치하는 레코드 삭제하는 행위 -> PK는 유니크 하기때문에 삭제라는 결과가 한번만 일어남
* 데이터 생성은 대부분 멱등성이 없다.
  * View의 전체 상태를 전파하게되면 데이터 생성에도 멱등성을 줄 수 있다.
* View의 전체 상태를 전파할때의 단점
  * 상태가 커지면 이벤트를 전송 할 때마다 네트워크 사용량이 늘어남.
    * 직렬화와 역직렬화 로직이 더많은 작업을 수행.
  * 하지만 실 서비스에서는 해당 트레이드오프를 멱등성으로 합리화함

#### CQRS 이해하기
* 명령 (Command)과 조회(Query)의 책임을 분리하는 아키텍처 패턴
  * 복잡성 분산
    * 쓰기 로직은 복잡할 수 있지만, 읽기 로직은 단순하게 가져갈 수 있음.
  * 성능 최적화
    * 조회는 캐싱, 읽기 전용 DB등으로 튜닝 가능
    * 쓰기는 안정성과 트랜잭션 위주로 처리 가능
  * 확장성
    * 읽기 / 쓰기 각각 따로 배포하고 확장할 수 있음.
    * Ex : 읽기 요청이 많은 서비스는 Query만 여러 대로 스케일업 가능
  * DDD 와 궁합이 잘 맞다고 함.