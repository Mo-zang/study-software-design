### 리스너를 통한 API의 확장성 제공
#### 리스너 사용 대 훅 사용
* 훅과 리스너의 차이
  * 리스너는 훅과 달리 선후관계가 존재하지 않음.
    * 리스너 API의 행위가 완료될 때까지 더 이상 기다릴 필요가 없음.
  * 실패를 처리하기 위한 규칙과, 코드를 병렬로 수행하는건 훅과 동일하나, 호출자가 전달된 상태를 변경하는것을 막을 수 없음.
#### 설계의 불변성
* 첫번째 리스너가 상태를 초기화 한다면, 두번째 리스너는 변경을 확인하지 못함.
  * 호출자의 코드가 초래하는 부작용이 존재함.
    * 우리 API를 오류에 취약하거나 비결정적이게 만듦.
* 클라이언트로 전파되는 실제 리스트의 사본 생성
  * 호출자가 객체를 변경하더라도 우리 API나 다른 리스너에 영향 제거.
  * 원본 객체의 깊은 복사가 필요할 경우 데이터 사본을 많이 생성해야함.
    * 메모리 사용량이 크게증가 -> 악영향
    * 리스너 코드에서 조용한 문제가 발생할지도 모르는 잠재적인 요소 존재.
    * 클라이언트가 리스트를 변경하는 상황을 의도 하지 않은 경우, 예외처리를 통해 명시적으로 금지되어 있다는 것을 알리는 편이 좋음.
* 상태를 불변 객체로 감싸는 방법
  * 위 기술된 두가지 문제를 모두 해결 가능함.
    * 책에 기술된 예로는 [ImmutableList](https://mng.bz/xvzd)가 있음.
  * 명시적이고 빠른 실패.
  * 실제 상태를 불변 객체로 감싸게 되면, 사본을 만들지 않음.
  * 기반 리스트의 변경에 대해 예외를 던지는 클래스를 생성.
  * 전파될 때 마다 리스트의 실제 내용을 복사할 필요 X
  * 메모리 사용량 감소.

